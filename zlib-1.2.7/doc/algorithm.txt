1. 압축 알고리즘 (deflate)

gzip (zip 및 zlib에서도 사용)에서 사용하는 deflation 알고리즘은 LZ77 (Lempel-Ziv 1977, 아래 참조)의 변형입니다. 입력 데이터에서 중복된 문자열을 찾습니다. 문자열의 두 번째 발생은 (거리, 길이) 쌍의 형태로 이전 문자열에 대한 포인터로 대체됩니다. 거리는 32K 바이트로 제한되고 길이는 258 바이트로 제한됩니다. 문자열이 이전 32K 바이트 어디에도 나타나지 않으면 리터럴 바이트 시퀀스로 출력됩니다. (이 설명에서 '문자열'은 임의의 바이트 시퀀스로 간주해야 하며 인쇄 가능한 문자로 제한되지 않습니다.)

리터럴 또는 일치 길이는 하나의 허프만 트리로 압축되고 일치 거리는 다른 트리로 압축됩니다. 트리는 각 블록의 시작 부분에 간결한 형태로 저장됩니다. 블록은 모든 크기를 가질 수 있습니다 (단, 한 블록에 대한 압축 데이터는 사용 가능한 메모리에 맞아야 함). deflate()가 새 트리로 다른 블록을 시작하는 것이 유용하다고 판단하면 블록이 종료됩니다. (이는 LZW 기반 _compress_의 동작과 다소 유사합니다.)

중복된 문자열은 해시 테이블을 사용하여 찾습니다. 길이 3의 모든 입력 문자열은 해시 테이블에 삽입됩니다. 다음 3바이트에 대한 해시 인덱스가 계산됩니다. 이 인덱스에 대한 해시 체인이 비어 있지 않으면 체인의 모든 문자열이 현재 입력 문자열과 비교되고 가장 긴 일치가 선택됩니다.

해시 체인은 가장 최근 문자열부터 검색되어 작은 거리를 선호하고 따라서 허프만 인코딩을 활용합니다. 해시 체인은 단일 연결됩니다. 해시 체인에서 삭제는 없으며 알고리즘은 단순히 너무 오래된 일치를 버립니다.

최악의 경우를 피하기 위해 매우 긴 해시 체인은 런타임 옵션(deflateInit의 수준 매개변수)에 의해 결정되는 특정 길이에서 임의로 잘립니다. 따라서 deflate()는 항상 가능한 가장 긴 일치를 찾는 것은 아니지만 일반적으로 충분히 긴 일치를 찾습니다.

deflate()는 또한 지연 평가 메커니즘을 사용하여 일치 선택을 지연시킵니다. 길이 N의 일치가 발견된 후 deflate()는 다음 입력 바이트에서 더 긴 일치를 검색합니다. 더 긴 일치가 발견되면 이전 일치는 길이 1로 잘리고(따라서 단일 리터럴 바이트 생성) 지연 평가 프로세스가 다시 시작됩니다. 그렇지 않으면 원래 일치가 유지되고 다음 일치 검색은 N 단계 후에만 시도됩니다.

지연 일치 평가는 런타임 매개변수의 영향을 받기도 합니다. 현재 일치가 충분히 길면 deflate()는 더 긴 일치 검색을 줄여 전체 프로세스 속도를 높입니다. 속도보다 압축률이 더 중요한 경우 deflate()는 첫 번째 일치가 이미 충분히 길더라도 전체 두 번째 검색을 시도합니다.

지연 일치 평가는 가장 빠른 압축 모드(수준 매개변수 1~3)에서는 수행되지 않습니다. 이러한 빠른 모드의 경우 새 문자열은 일치가 발견되지 않았거나 일치가 너무 길지 않은 경우에만 해시 테이블에 삽입됩니다. 이렇게 하면 압축률이 저하되지만 삽입 및 검색 횟수가 모두 줄어들어 시간이 절약됩니다.


2. 압축 해제 알고리즘 (inflate)

2.1 소개

핵심 질문은 허프만 코드(또는 모든 접두사 코드)를 빠르게 디코딩할 수 있도록 표현하는 방법입니다. 가장 중요한 특징은 짧은 코드가 긴 코드보다 훨씬 더 일반적이므로 짧은 코드를 빠르게 디코딩하는 데 주의를 기울이고 긴 코드는 디코딩하는 데 더 오래 걸리도록 하는 것입니다.

inflate()는 가장 긴 코드의 길이보다 작은 입력 비트 수를 포함하는 첫 번째 수준 테이블을 설정합니다. 스트림에서 해당 비트 수를 가져와 테이블에서 조회합니다. 테이블은 다음 코드가 해당 비트 수 이하인지 여부와 개수를 알려주고, 그렇다면 값을 알려줍니다. 그렇지 않으면 inflate()가 더 많은 비트를 가져와 더 긴 코드를 디코딩하려고 시도하는 다음 수준 테이블을 가리킵니다.

첫 번째 조회를 수행할 비트 수는 디코딩하는 데 걸리는 시간과 테이블을 빌드하는 데 걸리는 시간 사이의 절충안입니다. 테이블을 빌드하는 데 시간이 걸리지 않고 (무한한 메모리가 있다면) 가장 긴 코드까지 모두 포함하는 첫 번째 수준 테이블만 있을 것입니다. 그러나 짧은 코드가 이러한 테이블에 여러 번 복제되므로 더 많은 비트에 대해 테이블을 빌드하는 데 훨씬 더 많은 시간이 걸립니다. inflate()가 하는 일은 단순히 첫 번째 테이블의 비트 수를 변수로 만들고 해당 변수를 최대 속도로 설정하는 것입니다.

리터럴/길이 트리에 대해 286개의 가능한 코드가 있는 inflate의 경우 첫 번째 테이블의 크기는 9비트입니다. 또한 거리 트리에는 30개의 가능한 값이 있으며 첫 번째 테이블의 크기는 6비트입니다. 각 경우에 대해 테이블은 "평균" 코드 길이보다 1비트 더 길게 끝났습니다. 즉, 286개 기호에 대해 약 8비트보다 약간 더 길고 30개 기호에 대해 약 5비트보다 약간 짧은 대략적으로 평평한 코드의 코드 길이입니다.


2.2 inflate 테이블 조회에 대한 자세한 내용

좋습니다. 이 교묘하게 난독화된 inflate 트리가 실제로 어떻게 생겼는지 알고 싶으시군요. 허프만 트리가 아니라는 것은 맞습니다. 단순히 허프만 기호의 처음, 예를 들어 9비트에 대한 조회 테이블입니다. 기호는 1비트만큼 짧거나 15비트만큼 길 수 있습니다. 특정 기호가 9비트보다 짧으면 해당 기호의 변환은 해당 기호의 비트로 시작하는 모든 항목에 복제됩니다. 예를 들어 기호가 4비트이면 9비트 테이블에 32번 복제됩니다. 기호가 9비트 길이면 테이블에 한 번 나타납니다.

기호가 9비트보다 길면 테이블의 해당 항목은 나머지 비트에 대한 다른 유사한 테이블을 가리킵니다. 다시 말하지만, 필요에 따라 중복된 항목이 있습니다. 아이디어는 대부분의 경우 기호가 짧고 테이블 조회가 한 번만 있다는 것입니다. (이것이 애초에 데이터 압축의 전체 아이디어입니다.) 덜 일반적인 긴 기호의 경우 두 번의 조회가 있습니다. 정말 긴 기호가 있는 압축 방법이 있다면 효율적인 만큼 많은 수준의 조회를 가질 수 있습니다. inflate의 경우 두 번이면 충분합니다.

따라서 테이블 항목은 다른 테이블을 가리키거나(이 경우 위의 예에서 9비트가 사용됨) 기호에 대한 변환과 사용할 비트 수를 포함합니다. 그런 다음 사용되지 않은 다음 비트부터 다시 시작합니다.

가장 긴 기호가 몇 비트이든 상관없이 하나의 조회 테이블만 있으면 되지 않을까 궁금할 수 있습니다. 그 이유는 그렇게 하면 실제로 디코딩하는 것보다 중복된 기호 항목을 채우는 데 더 많은 시간을 소비하기 때문입니다. 적어도 몇만 바이트마다 새 트리를 생성하는 deflate의 출력에 대해서는 그렇습니다. 15비트 코드에 대해 2^15 항목 테이블을 채우는 것은 몇천 개의 기호만 디코딩하는 경우 너무 오래 걸릴 수 있습니다. 다른 극단적인 경우 코드의 모든 비트에 대해 새 테이블을 만들 수 있습니다. 사실, 그것은 본질적으로 허프만 트리입니다. 그러나 짧은 기호에 대해서도 디코딩하는 동안 트리를 순회하는 데 너무 많은 시간을 소비합니다.

따라서 첫 번째 조회 테이블의 비트 수는 테이블을 채우는 시간과 테이블의 두 번째 수준 이상을 보는 데 걸리는 시간 사이의 절충안입니다.

다음은 축소된 예입니다.

디코딩되는 코드, 10개 기호, 1~6비트 길이:

A: 0
B: 10
C: 1100
D: 11010
E: 11011
F: 11100
G: 11101
H: 11110
I: 111110
J: 111111

첫 번째 테이블을 3비트 길이(8개 항목)로 만들어 보겠습니다.

000: A,1
001: A,1
010: A,1
011: A,1
100: B,2
101: B,2
110: -> 테이블 X (3비트 사용)
111: -> 테이블 Y (3비트 사용)

각 항목은 비트가 디코딩되는 방식과 해당 비트 수, 즉 사용할 비트 수입니다. 또는 항목은 다른 테이블을 가리키며, 사용할 비트 수는 테이블 크기에 암시적으로 포함됩니다.

110으로 시작하는 가장 긴 코드가 5비트 길이이므로 테이블 X는 2비트 길이입니다.

00: C,1
01: C,1
10: D,2
11: E,2

111로 시작하는 가장 긴 코드가 6비트 길이이므로 테이블 Y는 3비트 길이입니다.

000: F,2
001: F,2
010: G,2
011: G,2
100: H,2
101: H,2
110: I,3
111: J,3

따라서 여기에는 총 20개의 항목이 있는 세 개의 테이블이 있으며, 이는 구성해야 했습니다. 이는 단일 테이블의 64개 항목과 비교됩니다. 또는 허프만 트리의 16개 항목(6개의 2개 항목 테이블과 1개의 4개 항목 테이블)과 비교됩니다. 코드가 기호의 확률을 이상적으로 나타낸다고 가정하면 기호당 평균 1.25번의 조회가 필요합니다. 이는 단일 테이블의 경우 1번의 조회, 허프만 트리의 경우 기호당 1.66번의 조회와 비교됩니다.

이제 상황이 어떻게 돌아가는지 알 수 있을 것입니다. inflate의 경우 특정 기호의 의미는 종종 단순한 문자 이상입니다. 바이트("리터럴")일 수도 있고, 기본값과 코드 뒤에 가져올 비트 수를 나타내는 길이 또는 거리일 수도 있으며, 이 비트 수는 기본값에 추가됩니다. 또는 특수 블록 끝 코드일 수도 있습니다. inftrees.c에서 생성된 데이터 구조는 테이블에 모든 정보를 간결하게 인코딩하려고 시도합니다.


Jean-loup Gailly        Mark Adler
jloup@gzip.org          madler@alumni.caltech.edu


참고 문헌:

[LZ77] Ziv J., Lempel A., ``A Universal Algorithm for Sequential Data
Compression,'' IEEE Transactions on Information Theory, Vol. 23, No. 3,
pp. 337-343.

``DEFLATE Compressed Data Format Specification''은 http://tools.ietf.org/html/rfc1951에서 볼 수 있습니다.
